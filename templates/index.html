<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Live Tsunami Simulation Control</title>
    <link
      rel="stylesheet"
      href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/proj4js/2.9.2/proj4.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <!-- Added Chart.js -->
    <!-- Removed simpleheat.js -->
    <style>
      body {
        margin: 0;
        padding: 0;
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto,
          Helvetica, Arial, sans-serif;
        display: flex;
        flex-direction: column;
        height: 100vh;
        background-color: #f8f9fa;
        color: #333;
      }
      #main-container {
        display: flex;
        flex-grow: 1;
        overflow: hidden;
      }
      #map-container {
        flex-grow: 1;
        display: flex;
        flex-direction: column;
        position: relative;
      }
      #map {
        flex-grow: 1;
        width: 100%;
        border-right: 1px solid #dee2e6;
      }
      #controls-panel {
        width: 380px; /* Slightly wider */
        flex-shrink: 0;
        background: #ffffff;
        padding: 20px;
        overflow-y: auto;
        border-left: 1px solid #dee2e6;
        display: flex;
        flex-direction: column;
        gap: 20px; /* Increased gap */
      }
      .control-group {
        border: 1px solid #e9ecef;
        padding: 15px;
        border-radius: 8px;
        background: #fff;
        box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
      }
      .control-group h3 {
        margin-top: 0;
        margin-bottom: 15px;
        font-size: 1.1em;
        font-weight: 600;
        color: #495057;
        border-bottom: 1px solid #e9ecef;
        padding-bottom: 8px;
      }
      /* Consistent spacing for elements within groups */
      .control-group > *:not(h3):not(.radio-group) {
        margin-bottom: 10px;
      } /* Adjust margin */
      .control-group > *:last-child {
        margin-bottom: 0;
      }
      .radio-group label {
        margin-right: 15px;
        font-size: 0.9em;
        cursor: pointer;
        display: inline-block;
        margin-bottom: 5px;
      } /* Display tweaks */
      .radio-group input[type="radio"] {
        margin-right: 5px;
        vertical-align: middle;
      }

      /* Input and Textarea Styles */
      input[type="number"],
      textarea {
        padding: 10px;
        font-size: 14px;
        border: 1px solid #ced4da;
        border-radius: 4px;
        width: 100%;
        box-sizing: border-box;
        transition: border-color 0.15s ease-in-out, box-shadow 0.15s ease-in-out;
      }
      input[type="number"]:focus,
      textarea:focus {
        border-color: #80bdff;
        outline: 0;
        box-shadow: 0 0 0 0.2rem rgba(0, 123, 255, 0.25);
      }
      textarea {
        height: 100px;
        resize: vertical;
        font-family: monospace;
      }

      /* Button Styles */
      button {
        padding: 10px 15px;
        font-size: 14px;
        font-weight: 500;
        border-radius: 4px;
        border: 1px solid transparent;
        cursor: pointer;
        transition: background-color 0.15s ease-in-out,
          border-color 0.15s ease-in-out, color 0.15s ease-in-out;
        width: 100%; /* Make buttons full width by default */
        box-sizing: border-box;
        background-color: #f8f9fa;
        border-color: #ced4da;
        color: #495057;
      }
      button:hover {
        background-color: #e9ecef;
        border-color: #adb5bd;
      }
      button:active {
        background-color: #dee2e6;
        border-color: #adb5bd;
      }
      button:disabled {
        cursor: not-allowed;
        background-color: #e9ecef;
        border-color: #e9ecef;
        color: #adb5bd;
        opacity: 0.65;
      }
      /* Primary action button style */
      #init-simulation,
      #play-pause {
        background-color: #007bff;
        border-color: #007bff;
        color: white;
      }
      #init-simulation:hover,
      #play-pause:hover {
        background-color: #0056b3;
        border-color: #0056b3;
      }
      #init-simulation:disabled,
      #play-pause:disabled {
        background-color: #007bff; /* Keep color but change opacity */
        border-color: #007bff;
        opacity: 0.65;
      }
      /* Destructive action button style */
      #reset-simulation {
        background-color: #dc3545;
        border-color: #dc3545;
        color: white;
      }
      #reset-simulation:hover {
        background-color: #c82333;
        border-color: #bd2130;
      }
      #reset-simulation:disabled {
        background-color: #dc3545;
        border-color: #dc3545;
        opacity: 0.65;
      }

      /* Specific Layouts */
      .step-execution-layout {
        display: flex;
        gap: 10px;
        align-items: center;
      }
      .step-execution-layout input[type="number"] {
        width: 80px;
        flex-shrink: 0;
        margin: 0;
      } /* Fixed width for number input */
      .step-execution-layout button {
        width: auto;
        flex-grow: 1;
        margin: 0;
      } /* Button takes remaining space */

      /* Info and Status */
      #info-display {
        font-size: 0.95em;
        color: #495057;
      }
      #status {
        margin-top: 8px;
        font-style: normal;
        color: #6c757d;
        font-size: 0.9em;
        min-height: 1.2em; /* Prevent layout shift */
      }
      .error-message {
        color: #dc3545;
        font-weight: 500;
      }

      /* Preformatted Text */
      pre {
        background: #f8f9fa;
        border: 1px solid #e9ecef;
        padding: 10px;
        border-radius: 4px;
        font-size: 0.85em; /* Slightly larger */
        max-height: 180px; /* Adjust height */
        overflow-y: auto;
        white-space: pre-wrap;
        word-wrap: break-word;
        color: #212529;
        font-family: SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono",
          "Courier New", monospace;
      }

      /* Legend Styles */
      .legend {
        padding: 8px 12px;
        background: rgba(255, 255, 255, 0.9);
        box-shadow: 0 1px 5px rgba(0, 0, 0, 0.2);
        border-radius: 5px;
        line-height: 1.8;
        font-size: 0.85em;
      }
      .legend strong {
        display: block;
        margin-bottom: 4px;
        font-weight: 600;
      }
      .legend hr {
        margin: 5px 0;
        border: 0;
        border-top: 1px solid #eee;
      }
      .legend i {
        width: 14px;
        height: 14px;
        float: left;
        margin-right: 8px;
        opacity: 0.9;
        border: 1px solid #666;
        vertical-align: middle;
        margin-top: 2px; /* Align better with text */
      }
      .legend .shelter-icon {
        border-radius: 50%;
        border: 2px solid darkgreen;
      }
      .legend .road-icon {
        border-radius: 0;
      }
      .legend .tsunami-icon {
        border-radius: 0;
        opacity: 0.6;
      }
      .legend .cost-gradient {
        width: 100%;
        height: 10px;
        margin-top: 4px;
        border: 1px solid #ccc;
      } /* Style for gradient bar */

      /* Removed heatmap canvas style */
    </style>
  </head>
  <body>
    <div id="main-container">
      <div id="map-container">
        <div id="map"></div>
        <!-- Removed heatmap canvas -->
      </div>
      <div id="controls-panel">
        <div class="control-group">
          <h3>Simulation Status</h3>
          <div id="info-display">Status: Initializing...</div>
          <div id="status">Loading...</div>
          <button id="check-health">Check API Health</button>
        </div>

        <div class="control-group">
          <h3>Core Controls</h3>
          <button id="init-simulation">Initialize Simulation</button>
          <button id="play-pause" disabled>Play/Pause Polling</button>
          <button id="reset-simulation" disabled>Reset Simulation</button>
        </div>

        <div class="control-group">
          <h3>Step Execution</h3>
          <button id="run-single-step" disabled>Run Single Step</button>
          <div class="step-execution-layout">
            <input type="number" id="run-steps-input" value="10" min="1" />
            <button id="run-multiple-steps" disabled>Run Steps</button>
          </div>
        </div>

        <div class="control-group">
          <h3>Visualization Options</h3>
          <div class="radio-group">
            <label
              ><input type="radio" name="costmap" value="none" checked />
              None</label
            >
            <label
              ><input type="radio" name="costmap" value="road" /> Dist. to
              Road</label
            >
            <label
              ><input type="radio" name="costmap" value="shelter" /> Dist. to
              Shelter</label
            >
            <label
              ><input type="radio" name="costmap" value="dtm" /> DTM
              (Elevation)</label
            >
          </div>
        </div>

        <div class="control-group">
          <h3>Configuration</h3>
          <button id="get-config">Get Current Config</button>
          <textarea
            id="config-textarea"
            placeholder="Current config will load here. Edit carefully or use fields below."
          ></textarea>
          <div>
            <label for="tsunami_delay">Tsunami Delay (steps):</label>
            <input
              type="number"
              id="tsunami_delay"
              name="tsunami_delay"
              min="0"
              placeholder="e.g., 100"
            />
          </div>
          <div>
            <label for="agent_reaction_delay"
              >Agent Reaction Delay (steps):</label
            >
            <input
              type="number"
              id="agent_reaction_delay"
              name="agent_reaction_delay"
              min="0"
              placeholder="e.g., 50"
            />
          </div>
          <div>
            <label
              style="
                display: inline-block;
                margin-right: 10px;
                font-size: 0.9em;
              "
            >
              <input type="checkbox" id="use-dtm-checkbox" /> Use DTM for Path
              Cost
            </label>
          </div>
          <button id="update-config">Update Config</button>
          <pre id="config-display">Config status will appear here...</pre>
        </div>

        <div class="control-group">
          <h3>Export & Charts</h3>
          <button id="export-results">Export Data & Update Charts</button>
          <div style="margin-top: 15px">
            <canvas id="deathChartCanvas" height="150"></canvas>
          </div>
          <div style="margin-top: 15px">
            <canvas id="shelterChartCanvas" height="150"></canvas>
          </div>
          <pre id="export-display" style="margin-top: 15px">
Export results will appear here...</pre
          >
        </div>
      </div>
    </div>

    <script>
      // --- Global Variables ---
      let map = null;
      let currentStep = 0;
      let totalAgents = 0;
      let isPolling = false;
      let isSimulationInitialized = false;
      let isSimulationRunning = false;
      let isSimulationCompleted = false;
      let pollingInterval = null;
      const pollingFrequency = 1500;
      let agentLayer = null;
      let gridLayer = null;
      let tsunamiLayer = null;
      let costLayer = null; // Layer for cost grid rectangles
      let currentCRS = null;
      let gridCostData = null; // To store fetched cost data
      let deathChart = null; // Chart instance variables
      let shelterChart = null;

      // --- DOM Elements ---
      const initBtn = document.getElementById("init-simulation");
      const playPauseBtn = document.getElementById("play-pause");
      const resetBtn = document.getElementById("reset-simulation");
      const runStepBtn = document.getElementById("run-single-step");
      const runStepsInput = document.getElementById("run-steps-input");
      const runStepsBtn = document.getElementById("run-multiple-steps");
      const healthBtn = document.getElementById("check-health");
      const getConfigBtn = document.getElementById("get-config");
      const updateConfigBtn = document.getElementById("update-config");
      const configTextarea = document.getElementById("config-textarea");
      const configDisplay = document.getElementById("config-display");
      const useDtmCheckbox = document.getElementById("use-dtm-checkbox"); // Get checkbox element
      const exportBtn = document.getElementById("export-results");
      const exportDisplay = document.getElementById("export-display");
      const infoDisplay = document.getElementById("info-display");
      const status = document.getElementById("status");
      const costmapRadios = document.querySelectorAll('input[name="costmap"]');
      const deathChartCanvas = document.getElementById("deathChartCanvas");
      const shelterChartCanvas = document.getElementById("shelterChartCanvas");
      // Removed heatmapCanvas

      // --- Projections ---
      proj4.defs(
        "EPSG:32749",
        "+proj=utm +zone=49 +south +datum=WGS84 +units=m +no_defs"
      );
      proj4.defs(
        "EPSG:32750",
        "+proj=utm +zone=50 +south +datum=WGS84 +units=m +no_defs"
      );

      // --- Helper Functions ---
      function convertToLatLng(x, y, sourceCRS) {
        /* ... (keep existing implementation) ... */
        if (!sourceCRS || !proj4.defs[sourceCRS]) {
          console.warn(`Source CRS '${sourceCRS}' not defined...`);
          if (Math.abs(x) <= 180 && Math.abs(y) <= 90) {
            return [y, x];
          }
          console.error(`Cannot project...`);
          return null;
        }
        try {
          if (!isFinite(x) || !isFinite(y)) return null;
          const [lng, lat] = proj4(sourceCRS, "EPSG:4326", [
            Number(x),
            Number(y),
          ]);
          if (!isFinite(lat) || !isFinite(lng)) return null;
          return [lat, lng];
        } catch (error) {
          console.error(`Error converting...`, error);
          return null;
        }
      }
      function getAgentColor(type) {
        /* ... (keep existing implementation) ... */
        switch (String(type).toLowerCase()) {
          case "adult":
            return "#ff0000";
          case "child":
            return "#00ff00";
          case "elder":
            return "#0000ff";
          case "teen":
            return "#ffA500";
          default:
            return "#999999";
        }
      }
      function updateInfoDisplay() {
        /* ... (keep existing implementation) ... */
        let simStatusText = "Idle";
        if (isSimulationInitialized) simStatusText = "Initialized";
        if (isSimulationRunning) simStatusText = "Running";
        if (isSimulationCompleted) simStatusText = "Completed";
        infoDisplay.textContent = `Step: ${currentStep} | Agents: ${totalAgents} | Status: ${simStatusText}`;
      }
      function setStatusMessage(message, isError = false) {
        /* ... (keep existing implementation) ... */
        status.textContent = message;
        if (isError) {
          status.classList.add("error-message");
        } else {
          status.classList.remove("error-message");
        }
      }
      function updateButtonStates() {
        /* ... (keep existing implementation) ... */
        initBtn.disabled = isSimulationInitialized;
        resetBtn.disabled = !isSimulationInitialized;
        playPauseBtn.disabled =
          !isSimulationInitialized || isSimulationCompleted;
        runStepBtn.disabled =
          !isSimulationInitialized || isSimulationCompleted || isPolling;
        runStepsBtn.disabled =
          !isSimulationInitialized || isSimulationCompleted || isPolling;
        updateConfigBtn.disabled = isSimulationInitialized;
        exportBtn.disabled = !isSimulationInitialized;
      }
      async function apiFetch(endpoint, options = {}) {
        const url = endpoint; // Use the endpoint directly without adding /api
        setStatusMessage(`Sending request to ${url}...`);
        try {
          const response = await fetch(url, options); // Fetch the correct URL
          // Check if response is ok AND content type is JSON before parsing
          const contentType = response.headers.get("content-type");
          if (!response.ok) {
            const errorText = await response.text();
            console.error(
              `API Error: Status ${response.status}, URL: ${url}, Response:`,
              errorText
            );
            throw new Error(`HTTP error ${response.status}`);
          }
          // Only parse if content type indicates JSON to avoid "Unexpected token '<'"
          if (contentType && contentType.includes("application/json")) {
            const result = await response.json();
            setStatusMessage(`${options.method || "GET"} ${url} successful.`);
            return result;
          } else {
            // Handle cases where response is OK but not JSON (if applicable)
            console.warn(
              `Received non-JSON response for ${url}, Content-Type: ${contentType}`
            );
            // Return something sensible or throw an error depending on expected behavior
            return {
              status: "ok",
              message: "Received non-JSON response",
              contentType: contentType,
            };
          }
        } catch (error) {
          console.error(`Error fetching ${url}:`, error);
          setStatusMessage(`Error: ${error.message}`, true);
          throw error; // Re-throw the error to be caught by the caller
        }
      }

      // --- Map Initialization ---
      function initMap() {
        map = L.map("map").setView([-8.4095, 115.1889], 8);
        // Create panes for layering
        map.createPane("costPane"); // Pane for cost grid layer
        map.getPane("costPane").style.zIndex = 425; // Below grid features
        map.createPane("gridPane");
        map.getPane("gridPane").style.zIndex = 450; // Roads below agents
        map.createPane("tsunamiPane");
        map.getPane("tsunamiPane").style.zIndex = 475; // Tsunami below agents but above grid
        map.createPane("agentPane");
        map.getPane("agentPane").style.zIndex = 500; // Agents
        map.createPane("shelterPane");
        map.getPane("shelterPane").style.zIndex = 550; // Shelters on top

        L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
          attribution:
            '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
        }).addTo(map);
        L.control.scale().addTo(map);
        addLegend();
        // Removed heatmap init and map move listener
        return map;
      }
      function addLegend() {
        const legend = L.control({ position: "bottomright" });
        legend.onAdd = function (map) {
          const div = L.DomUtil.create("div", "legend");
          div.innerHTML = `
                    <strong>Legend</strong><br>
                    <i class="road-icon" style="background: #888"></i> Road<br>
                    <i class="shelter-icon" style="background: #006400"></i> Shelter<br>
                    <i class="tsunami-icon" style="background: blue;"></i> Tsunami<br>
                    <div class="cost-gradient" style="background: linear-gradient(to right, lime, yellow, red);"></div> <!-- Updated Gradient -->
                    <span style="float: left; font-size: 0.8em;">Low</span>
                    <span style="float: right; font-size: 0.8em;">High</span>
                    <div style="clear: both;"></div>
                    <hr style="margin: 5px 0;">
                    <strong>Agent Types</strong><br>
                    <i style="background: #ff0000"></i> Adult<br>
                    <i style="background: #00ff00"></i> Child<br>
                    <i style="background: #0000ff"></i> Elder<br>
                    <i style="background: #ffA500"></i> Teen<br>
                    <i style="background: #999999"></i> Unknown/Other
                `;
          return div;
        };
        legend.addTo(map);
      }

      // --- Data Fetching & Visualization ---
      async function fetchMetadata() {
        /* ... (keep existing implementation) ... */
        try {
          const response = await fetch("/data/metadata");
          if (!response.ok) {
            const errorData = await response
              .json()
              .catch(() => ({ error: `HTTP error ${response.status}` }));
            throw new Error(errorData.error || `HTTP error ${response.status}`);
          }
          const statusData = await response.json();
          const simState = statusData.simulation_state || {};
          currentStep = simState.current_step || 0;
          isSimulationRunning = simState.is_running || false;
          isSimulationCompleted = simState.is_completed || false;
          isSimulationInitialized =
            simState.is_running || simState.is_completed;
          totalAgents = statusData.agents_count || 0;
          updateInfoDisplay();
          updateButtonStates();
          if (!status.classList.contains("error-message")) {
            setStatusMessage(
              isSimulationRunning
                ? "Simulation running..."
                : isSimulationCompleted
                ? "Simulation completed."
                : isSimulationInitialized
                ? "Simulation Initialized."
                : "Simulation Idle."
            );
          }
          return statusData;
        } catch (error) {
          console.error("Error loading metadata:", error);
          setStatusMessage(`Error loading metadata: ${error.message}`, true);
          playPauseBtn.disabled = true;
          updateButtonStates();
          return null;
        }
      }
      async function fetchCurrentGeojsonData() {
        /* ... (keep existing implementation) ... */
        try {
          const response = await fetch("/data/current_geojson");
          if (!response.ok) {
            const errorData = await response
              .json()
              .catch(() => ({ error: `HTTP error ${response.status}` }));
            throw new Error(errorData.error || `HTTP error ${response.status}`);
          }
          const geojsonData = await response.json();
          if (!geojsonData || geojsonData.type !== "FeatureCollection") {
            throw new Error("Invalid GeoJSON data received");
          }
          currentCRS = geojsonData.crs?.properties?.name;
          if (currentCRS && !proj4.defs[currentCRS]) {
            console.warn(`CRS ${currentCRS} defined...`);
          }
          return geojsonData;
        } catch (error) {
          console.error("Error loading GeoJSON:", error);
          setStatusMessage(`Error loading agent data: ${error.message}`, true);
          if (isPolling) {
            togglePolling();
          }
          return null;
        }
      }
      async function fetchGridCosts() {
        /* ... (keep existing implementation) ... */
        // REMOVED: if (gridCostData) return gridCostData; // Force fetch every time
        try {
          setStatusMessage("Fetching grid cost data...");
          gridCostData = await apiFetch("/api/grid/costs");
          // --- ADD LOGGING HERE ---
          console.log("Received gridCostData:", JSON.stringify(gridCostData)); // Log the full structure
          if (gridCostData && gridCostData.distance_to_road) {
            console.log(
              "Sample distance_to_road data (first 5 rows):",
              gridCostData.distance_to_road.slice(0, 5)
            );
          }
          // --- END LOGGING ---
          if (
            !gridCostData ||
            !gridCostData.distance_to_road ||
            !gridCostData.distance_to_shelter
          ) {
            throw new Error("Incomplete cost data received");
          }
          setStatusMessage("Grid cost data loaded.");
          return gridCostData;
        } catch (error) {
          setStatusMessage(`Error fetching grid costs: ${error.message}`, true);
          gridCostData = null; // Clear cache on error
          return null;
        }
      }

      // --- Rendering Functions ---
      async function renderGridLayer() {
        /* ... (keep existing implementation) ... */
        if (gridLayer) map.removeLayer(gridLayer);
        try {
          setStatusMessage("Fetching grid data...");
          const gridGeoJson = await apiFetch("/api/grid/geojson");
          if (!gridGeoJson || !gridGeoJson.features) {
            throw new Error("Invalid grid GeoJSON received");
          }
          const gridCRS = gridGeoJson.crs?.properties?.name || currentCRS;
          gridLayer = L.featureGroup([], { pane: "gridPane" });
          L.geoJSON(gridGeoJson, {
            filter: function (feature) {
              return feature.properties && feature.properties.type === "road";
            },
            pointToLayer: function (feature, latlng) {
              return L.circleMarker(latlng, {
                radius: 3,
                weight: 1,
                opacity: 0.8,
                fillOpacity: 0.6,
                fillColor: "#888888",
                color: "#555555",
              });
            },
            coordsToLatLng: function (coords) {
              const latLng = convertToLatLng(coords[0], coords[1], gridCRS);
              return latLng ? L.latLng(latLng[0], latLng[1]) : null;
            },
          }).addTo(gridLayer);
          L.geoJSON(gridGeoJson, {
            filter: function (feature) {
              return (
                feature.properties && feature.properties.type === "shelter"
              );
            },
            pointToLayer: function (feature, latlng) {
              return L.circleMarker(latlng, {
                pane: "shelterPane",
                radius: 7,
                fillColor: "#006400",
                color: "#004d00",
                weight: 1,
                opacity: 0.9,
                fillOpacity: 0.7,
              }).bindPopup(`Shelter ID: ${feature.properties.id}`);
            },
            coordsToLatLng: function (coords) {
              const latLng = convertToLatLng(coords[0], coords[1], gridCRS);
              return latLng ? L.latLng(latLng[0], latLng[1]) : null;
            },
          }).addTo(map);
          gridLayer.addTo(map);
          setStatusMessage("Grid data rendered.");
        } catch (error) {
          setStatusMessage(`Error rendering grid: ${error.message}`, true);
        }
      }
      function renderTsunamiLayer(tsunamiGeoJson) {
        /* ... (keep existing implementation) ... */
        if (!map) return;
        if (tsunamiLayer) map.removeLayer(tsunamiLayer);
        if (
          !tsunamiGeoJson ||
          !tsunamiGeoJson.features ||
          tsunamiGeoJson.features.length === 0
        ) {
          console.log("No active tsunami data...");
          tsunamiLayer = null;
          return;
        }
        const tsunamiCRS = tsunamiGeoJson.crs?.properties?.name || currentCRS;
        tsunamiLayer = L.geoJSON(tsunamiGeoJson, {
          pane: "tsunamiPane",
          pointToLayer: function (feature, latlng) {
            const height = feature.properties.height || 1;
            return L.rectangle(latlng.toBounds(5), {
              fillColor: "blue",
              color: "#0000AA",
              weight: 0,
              fillOpacity: 0.4 + height / 20,
            });
          },
          coordsToLatLng: function (coords) {
            const latLng = convertToLatLng(coords[0], coords[1], tsunamiCRS);
            return latLng ? L.latLng(latLng[0], latLng[1]) : null;
          },
        }).addTo(map);
        console.log(
          `Rendered ${tsunamiGeoJson.features.length} tsunami points.`
        );
      }
      function updateAgentVisualization(geojsonData) {
        if (!map || !geojsonData || !geojsonData.features) return;
        if (agentLayer) {
          map.removeLayer(agentLayer);
        }
        agentLayer = L.featureGroup([], { pane: "agentPane" });
        let validPointCount = 0;
        let invalidPointCount = 0;

        geojsonData.features.forEach((feature) => {
          // Expect Point geometry now from the updated /api/export/geojson
          if (
            feature.geometry &&
            feature.geometry.type === "Point" &&
            feature.geometry.coordinates
          ) {
            const agentType = feature.properties.agent_type;
            const agentId = feature.properties.id; // Get agent ID
            const coordPair = feature.geometry.coordinates; // Direct coordinates for Point

            const latLng = convertToLatLng(
              coordPair[0],
              coordPair[1],
              currentCRS
            );
            if (latLng) {
              const marker = L.circleMarker(latLng, {
                radius: 6,
                fillColor: getAgentColor(agentType),
                color: "#000",
                weight: 1,
                opacity: 1,
                fillOpacity: 0.8,
              });
              // Store the agent ID from properties
              marker.options.agentId = agentId; // Store the ID
              marker.on("click", showAgentInfo); // Add click listener
              // marker.bindTooltip(`ID: ${agentId} Type: ${agentType}`); // Optional: Add ID to tooltip
              marker.addTo(agentLayer);
              validPointCount++;
            } else {
              console.warn(
                `Failed to convert coordinates for agent ${agentId}:`,
                coordPair
              );
              invalidPointCount++;
            }
          } else {
            // Log warning if geometry is not Point (or missing)
            console.warn(
              "Skipping feature with unexpected/missing geometry:",
              feature.geometry?.type
            );
            invalidPointCount++;
          }
        }); // End forEach feature

        agentLayer.addTo(map);
        if (!status.classList.contains("error-message")) {
          setStatusMessage(
            `Showing ${validPointCount} agents. ${
              invalidPointCount > 0
                ? `(${invalidPointCount} invalid/skipped)`
                : ""
            }`
          );
        }
        // Fit bounds only on initial load or reset
        // if (currentStep <= 1 && agentLayer.getLayers().length > 0) {
        //     const bounds = agentLayer.getBounds();
        //     if (bounds.isValid()) { map.fitBounds(bounds); }
        // }
      }

      // --- New Function to Show Agent Info ---
      async function showAgentInfo(e) {
        const marker = e.target;
        const agentId = marker.options.agentId; // Retrieve stored agent ID
        console.log(
          "Clicked agent marker. Agent ID from marker options:",
          agentId
        ); // Log the ID

        // More robust check for valid ID
        if (agentId === undefined || agentId === null || agentId === "") {
          marker
            .bindPopup("Agent ID not available for this marker.")
            .openPopup();
          console.error(
            "Agent ID is undefined, null, or empty for the clicked marker."
          );
          return;
        }

        const fetchUrl = `api/agent/${agentId}`; // Use relative path
        // Removed duplicate line below
        console.log("Attempting to fetch:", fetchUrl);
        marker.bindPopup(`Loading info for Agent ${agentId}...`).openPopup(); // Show loading message with ID

        try {
          // Use the apiFetch helper function which handles the endpoint correctly
          const agentData = await apiFetch(fetchUrl); // Use apiFetch
          console.log("Received agent data:", agentData);

          // Format the agent data for display
          let infoString = `<strong>Agent ID: ${agentData.id}</strong><br>`;
          infoString += `Type: ${agentData.agent_type}<br>`;
          infoString += `Status: ${agentData.is_alive ? "Alive" : "Dead"}<br>`;
          infoString += `Position: (${agentData.x}, ${agentData.y})<br>`;
          infoString += `On Road: ${agentData.is_on_road}<br>`;
          infoString += `In Shelter: ${agentData.is_in_shelter}<br>`;
          infoString += `Knowledge: ${agentData.knowledge_level}<br>`;
          infoString += `Household Size: ${agentData.household_size}<br>`;
          infoString += `Decided to Evacuate: ${agentData.has_decided_to_evacuate}<br>`;
          infoString += `Trigger Time: ${
            agentData.evacuation_trigger_time ?? "N/A"
          }<br>`;
          infoString += `Milling Remaining: ${agentData.milling_steps_remaining}<br>`;
          // Add more fields as needed

          marker.bindPopup(infoString).openPopup();
        } catch (error) {
          marker.bindPopup(`Error loading info: ${error.message}`).openPopup();
        }
      }

      // --- Cost Grid Rendering (Replaces Heatmap) ---
      function renderCostGridLayer(mode) {
        if (!map) return;
        // Clear previous cost layer
        if (costLayer) {
          map.removeLayer(costLayer);
          costLayer = null;
        }

        if (mode === "none" || !gridCostData) {
          console.log("Cost map display set to none or data not loaded.");
          return; // Don't render if mode is 'none' or data is missing
        }

        let valueArray; // Use generic name: cost or elevation
        let colorInterpolation; // Function to map value to color

        // Select data array and color function based on mode
        if (mode === "road") {
          valueArray = gridCostData.distance_to_road;
          // Lime (low) -> Yellow (mid) -> Red (high) for distance cost
          colorInterpolation = (normVal) => {
            let r, g;
            // Make transition to yellow/red happen sooner (e.g., around 0.3 instead of 0.5)
            const transitionPoint = 0.3; // Adjust this value (0.0 to 1.0)
            if (normVal < transitionPoint) {
              // Interpolate Lime (0, 255, 0) to Yellow (255, 255, 0)
              r = Math.round(255 * (normVal / transitionPoint));
              g = 255;
            } else {
              // Interpolate Yellow (255, 255, 0) to Red (255, 0, 0)
              r = 255;
              g = Math.round(
                255 * (1 - (normVal - transitionPoint) / (1 - transitionPoint))
              );
            }
            // Ensure g stays within 0-255
            g = Math.max(0, Math.min(255, g));
            return `rgb(${r}, ${g}, 0)`;
          };
        } else if (mode === "shelter") {
          valueArray = gridCostData.distance_to_shelter;
          // Use same adjusted Lime -> Red gradient for shelter distance
          colorInterpolation = (normVal) => {
            let r, g;
            const transitionPoint = 0.3; // Keep consistent with 'road'
            if (normVal < transitionPoint) {
              r = Math.round(255 * (normVal / transitionPoint));
              g = 255;
            } else {
              r = 255;
              g = Math.round(
                255 * (1 - (normVal - transitionPoint) / (1 - transitionPoint))
              );
            }
            g = Math.max(0, Math.min(255, g));
            return `rgb(${r}, ${g}, 0)`;
          };
        } else if (mode === "dtm") {
          valueArray = gridCostData.environment_layers?.dtm; // Access the DTM layer
          // Grayscale for DTM: Black (low) to White (high)
          colorInterpolation = (normVal) => {
            const intensity = Math.round(255 * normVal);
            return `rgb(${intensity}, ${intensity}, ${intensity})`;
          };
        } else {
          console.error(`Unknown cost map mode: ${mode}`);
          return;
        }

        // Ensure the selected data array exists
        if (!valueArray) {
          console.error(`Data for mode '${mode}' not found in gridCostData.`);
          setStatusMessage(`Data for mode '${mode}' not available.`, true);
          return;
        }

        const { nrows, ncols, xllcorner, yllcorner, cellsize } = gridCostData;
        const gridCRS = currentCRS || "EPSG:32749"; // Assume CRS if needed

        // Find min/max for normalization from the selected valueArray
        let maxValue = -Infinity;
        let minValue = Infinity;
        let validValueCount = 0;
        for (let r = 0; r < nrows; r++) {
          for (let c = 0; c < ncols; c++) {
            // Use optional chaining for safety
            const value = valueArray[r]?.[c];
            if (value !== null && value !== undefined) {
              validValueCount++;
              if (value > maxValue) maxValue = value;
              if (value < minValue) minValue = value;
            }
          }
        }
        // Handle edge cases for normalization range
        if (minValue === Infinity) minValue = 0; // No valid values found
        if (maxValue === -Infinity) maxValue = minValue; // No valid values or all same
        const valueRange = Math.max(1e-6, maxValue - minValue); // Use epsilon

        console.log(
          `Rendering grid for '${mode}'. Min: ${minValue}, Max: ${maxValue}, Range: ${valueRange}, Valid Cells: ${validValueCount}`
        );

        // Create a feature group for the cost rectangles, assign to costPane
        costLayer = L.featureGroup([], { pane: "costPane" });

        // Iterate and create rectangles
        for (let r = 0; r < nrows; r++) {
          for (let c = 0; c < ncols; c++) {
            const value = valueArray[r]?.[c]; // Use value instead of cost

            // Only draw cells with a valid value
            if (value !== null && value !== undefined) {
              // Calculate cell bounds
              const utmX1 = xllcorner + c * cellsize;
              const utmY1 = yllcorner + (nrows - 1 - r) * cellsize; // Bottom-left Y
              const utmX2 = utmX1 + cellsize;
              const utmY2 = utmY1 + cellsize; // Top Y

              const ll = convertToLatLng(utmX1, utmY1, gridCRS);
              const ur = convertToLatLng(utmX2, utmY2, gridCRS);

              if (ll && ur) {
                const bounds = L.latLngBounds([
                  [ll[0], ll[1]],
                  [ur[0], ur[1]],
                ]);
                // Normalize value to 0-1 range
                const normalizedValue = (value - minValue) / valueRange;

                // Log values for non-road cells for debugging
                if (mode === "road" && value > 0) {
                  console.log(
                    `  Cell(${r},${c}): Cost=${value}, Norm=${normalizedValue.toFixed(
                      3
                    )}`
                  );
                }

                // Get color using the selected interpolation function
                const color = colorInterpolation(normalizedValue);

                L.rectangle(bounds, {
                  color: color,
                  weight: 0,
                  fillColor: color,
                  fillOpacity: 0.45, // Adjust opacity
                }).addTo(costLayer);
              }
            }
          }
        }
        costLayer.addTo(map); // Add the layer group to the map
        setStatusMessage(`Rendered grid for '${mode}'.`);
      }

      // --- Main Refresh Function ---
      async function refreshDataAndMap() {
        setStatusMessage("Fetching latest data...");
        const metadata = await fetchMetadata(); // Updates global state and buttons
        if (metadata && isSimulationInitialized) {
          // Fetch agent and tsunami data concurrently
          const [agentGeoJson, tsunamiGeoJson] = await Promise.all([
            fetchCurrentGeojsonData(),
            apiFetch("/api/tsunami/geojson"), // Fetch tsunami data
          ]);

          if (agentGeoJson) {
            updateAgentVisualization(agentGeoJson); // Update agent layer
          }
          renderTsunamiLayer(tsunamiGeoJson); // Render tsunami layer
          // Cost grid is NOT redrawn on every refresh automatically
          // It's only redrawn when the radio button selection changes or on init/reset
        } else {
          // If not initialized, ensure other layers are also cleared
          if (tsunamiLayer) map.removeLayer(tsunamiLayer);
          tsunamiLayer = null;
          if (costLayer) map.removeLayer(costLayer); // Clear cost grid
          costLayer = null;
        }
        // If simulation completed while polling, stop
        if (isSimulationCompleted && isPolling) {
          togglePolling();
          setStatusMessage("Simulation completed.");
        }
      }

      // --- Chart Rendering Functions ---
      function renderDeathChart(steps, deathCounts) {
        if (!deathChartCanvas) return;
        const ctx = deathChartCanvas.getContext("2d");

        // Extract total deaths per step
        const totalDeaths = deathCounts.map((d) => d.dead_agents.total);

        // Destroy existing chart instance before creating a new one
        if (deathChart) {
          deathChart.destroy();
        }

        // Create a new chart instance
        deathChart = new Chart(ctx, {
          type: "line",
          data: {
            labels: steps,
            datasets: [
              {
                label: "Total Dead Agents",
                data: totalDeaths,
                borderColor: "rgb(220, 53, 69)", // Red
                tension: 0.1,
                fill: false,
              },
            ],
          },
          options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
              y: { beginAtZero: true, title: { display: true, text: "Count" } },
              x: { title: { display: true, text: "Step" } },
            },
            plugins: { legend: { display: true } },
          },
        });
      }

      function renderShelterChart(steps, shelterData) {
        if (!shelterChartCanvas) return;
        const ctx = shelterChartCanvas.getContext("2d");

        // Process shelter data for stacked bar chart
        const shelterIDs = new Set();
        shelterData.forEach((stepData) => {
          Object.keys(stepData.shelters).forEach((key) => shelterIDs.add(key));
        });
        const sortedShelterIDs = Array.from(shelterIDs).sort();

        const datasets = sortedShelterIDs.map((shelterId) => {
          const data = steps.map((step) => {
            const stepEntry = shelterData.find((sd) => sd.step === step);
            const shelterCounts = stepEntry?.shelters?.[shelterId];
            return shelterCounts
              ? shelterCounts.child +
                  shelterCounts.teen +
                  shelterCounts.adult +
                  shelterCounts.elder
              : 0;
          });
          // Basic color cycling - could be improved
          const colorIndex = sortedShelterIDs.indexOf(shelterId) % 5; // Example: cycle through 5 colors
          const colors = [
            "rgba(40, 167, 69, 0.7)",
            "rgba(23, 162, 184, 0.7)",
            "rgba(255, 193, 7, 0.7)",
            "rgba(108, 117, 125, 0.7)",
            "rgba(52, 58, 64, 0.7)",
          ];

          return {
            label: shelterId,
            data: data,
            backgroundColor: colors[colorIndex],
          };
        });

        if (shelterChart) {
          shelterChart.data.labels = steps;
          shelterChart.data.datasets = datasets;
          shelterChart.update();
        } else {
          shelterChart = new Chart(ctx, {
            type: "bar",
            data: {
              labels: steps,
              datasets: datasets,
            },
            options: {
              responsive: true,
              maintainAspectRatio: false,
              scales: {
                x: { stacked: true, title: { display: true, text: "Step" } },
                y: {
                  stacked: true,
                  beginAtZero: true,
                  title: { display: true, text: "Agents in Shelter" },
                },
              },
              plugins: { legend: { display: true } },
            },
          });
        }
      }

      // --- Polling Control ---
      function togglePolling() {
        /* ... (keep existing implementation) ... */
        isPolling = !isPolling;
        playPauseBtn.textContent = isPolling
          ? "Pause Polling"
          : "Resume Polling";
        updateButtonStates();
        if (isPolling) {
          refreshDataAndMap();
          pollingInterval = setInterval(refreshDataAndMap, pollingFrequency);
          setStatusMessage("Polling for live data...");
        } else {
          clearInterval(pollingInterval);
          pollingInterval = null;
          if (!status.classList.contains("error-message")) {
            setStatusMessage("Polling paused.");
          }
        }
      }

      // --- Event Listeners ---
      initBtn.addEventListener("click", async () => {
        setStatusMessage("Resetting simulation state before init...", false);
        initBtn.disabled = true;
        playPauseBtn.disabled = true;
        resetBtn.disabled = true;
        gridCostData = null; // Clear cached cost data on init
        if (costLayer) map.removeLayer(costLayer);
        costLayer = null; // Clear cost layer

        try {
          try {
            await apiFetch("/api/reset", { method: "POST" });
            setStatusMessage("Previous state reset. Now initializing...");
          } catch (resetError) {
            console.warn("Reset before init failed:", resetError);
            setStatusMessage("Reset failed. Attempting initialization...");
          }

          const result = await apiFetch("/init_simulation", { method: "POST" });
          setStatusMessage(`Simulation initialized: ${result.message || "OK"}`);
          isSimulationInitialized = true;

          // Fetch grid and cost data *after* successful init
          await fetchGridCosts(); // Fetch and cache cost data
          await renderGridLayer(); // Render static grid
          await refreshDataAndMap(); // Fetch initial agent/tsunami state and map

          if (agentLayer && map && agentLayer.getLayers().length > 0) {
            const bounds = agentLayer.getBounds();
            if (bounds.isValid()) map.fitBounds(bounds);
          }
          // Draw initial cost grid based on selection AFTER data is fetched
          renderCostGridLayer(
            document.querySelector('input[name="costmap"]:checked').value
          );
        } catch (error) {
          initBtn.disabled = false;
        } finally {
          updateButtonStates();
        }
      });

      playPauseBtn.addEventListener("click", togglePolling);

      resetBtn.addEventListener("click", async () => {
        /* ... (keep existing implementation, clear cost data/layer) ... */
        if (!confirm("Are you sure?")) return;
        setStatusMessage("Resetting simulation...", false);
        if (isPolling) togglePolling();
        try {
          const result = await apiFetch("/api/reset", { method: "POST" });
          setStatusMessage(`Simulation reset: ${result.message || "OK"}`);
          isSimulationInitialized = false;
          isSimulationRunning = false;
          isSimulationCompleted = false;
          currentStep = 0;
          totalAgents = 0;
          if (agentLayer) map.removeLayer(agentLayer);
          if (gridLayer) map.removeLayer(gridLayer);
          if (tsunamiLayer) map.removeLayer(tsunamiLayer);
          if (costLayer) map.removeLayer(costLayer);
          agentLayer = null;
          gridLayer = null;
          tsunamiLayer = null;
          costLayer = null;
          gridCostData = null;
          await fetchMetadata();
        } catch (error) {
          /* Handled */
        } finally {
          updateButtonStates();
        }
      });

      runStepBtn.addEventListener("click", async () => {
        /* ... (keep existing implementation) ... */
        setStatusMessage("Running single step...", false);
        runStepBtn.disabled = true;
        runStepsBtn.disabled = true;
        try {
          const result = await apiFetch("/api/step", { method: "POST" });
          setStatusMessage(
            `Step executed. Current step: ${
              result?.simulation_state?.current_step || "N/A"
            }`
          );
          await refreshDataAndMap();
        } catch (error) {
          /* Handled */
        } finally {
          updateButtonStates();
        }
      });

      runStepsBtn.addEventListener("click", async () => {
        /* ... (keep existing implementation) ... */
        const steps = parseInt(runStepsInput.value);
        if (isNaN(steps) || steps < 1) {
          setStatusMessage("Invalid number of steps.", true);
          return;
        }
        setStatusMessage(`Running ${steps} steps...`, false);
        runStepBtn.disabled = true;
        runStepsBtn.disabled = true;
        try {
          const result = await apiFetch(`/api/run/${steps}`, {
            method: "POST",
            timeout: 60000,
          });
          setStatusMessage(
            `${result?.steps_executed || 0} steps executed. Current step: ${
              result?.simulation_state?.current_step || "N/A"
            }`
          );
          await refreshDataAndMap();
        } catch (error) {
          /* Handled */
        } finally {
          updateButtonStates();
        }
      });

      healthBtn.addEventListener("click", async () => {
        /* ... (keep existing implementation) ... */
        try {
          const result = await apiFetch("/api/health");
          setStatusMessage(`API Health: ${result.status} - ${result.message}`);
        } catch (error) {
          /* Handled */
        }
      });

      getConfigBtn.addEventListener("click", async () => {
        try {
          const result = await apiFetch("/api/config");
          // Populate textarea, new input fields, and checkbox
          configTextarea.value = JSON.stringify(result, null, 2);
          document.getElementById("tsunami_delay").value =
            result.tsunami_delay ?? 100; // Use default if null/undefined
          document.getElementById("agent_reaction_delay").value =
            result.agent_reaction_delay ?? 50; // Use default if null/undefined
          useDtmCheckbox.checked = result.use_dtm_for_cost === true;
          configDisplay.textContent = "Current config loaded into fields."; // Update display message
          setStatusMessage("Current config loaded.");
        } catch (error) {
          configDisplay.textContent = `Error loading config: ${error.message}`;
          setStatusMessage(`Error loading config: ${error.message}`, true);
        }
      });

      updateConfigBtn.addEventListener("click", async () => {
        setStatusMessage("Fetching current config to update...", false);
        let currentConfig;
        try {
          currentConfig = await apiFetch("/api/config"); // Fetch current config first
        } catch (error) {
          setStatusMessage(
            "Failed to fetch current config. Cannot update.",
            true
          );
          return;
        }

        // Read values from specific input fields
        const tsunamiDelayInput = document.getElementById("tsunami_delay");
        const agentReactionDelayInput = document.getElementById(
          "agent_reaction_delay"
        );

        // Parse values from inputs, providing defaults based on fetched config or hardcoded defaults
        const tsunamiDelay =
          parseInt(tsunamiDelayInput.value) ||
          currentConfig.tsunami_delay ||
          100;
        const agentReactionDelay =
          parseInt(agentReactionDelayInput.value) ||
          currentConfig.agent_reaction_delay ||
          50;
        const useDtm = useDtmCheckbox.checked;

        // Update the fetched config object
        currentConfig.tsunami_delay = tsunamiDelay;
        currentConfig.agent_reaction_delay = agentReactionDelay;
        currentConfig.use_dtm_for_cost = useDtm;

        // Update the textarea to show the config *being sent*
        configTextarea.value = JSON.stringify(currentConfig, null, 2);

        setStatusMessage("Sending updated config...", false);
        try {
          const result = await apiFetch("/api/config", {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(currentConfig), // Send the updated object
          });
          setStatusMessage(`Config updated: ${result.message || "OK"}`);
          // Optionally refresh the display again to confirm, or rely on the textarea update above
          // getConfigBtn.click();
          configDisplay.textContent = "Config updated successfully.";
        } catch (error) {
          /* Error message already set by apiFetch */
        }
      });

      exportBtn.addEventListener("click", async () => {
        /* ... (keep existing implementation) ... */
        try {
          const result = await apiFetch("/api/export");
          exportDisplay.textContent = JSON.stringify(result, null, 2); // Show raw data too

          // Process and render charts
          if (result.death_data && result.shelter_data) {
            const steps = result.death_data.map((d) => d.step);
            renderDeathChart(steps, result.death_data);
            renderShelterChart(steps, result.shelter_data);
            setStatusMessage("Data exported and charts updated.");
          } else {
            setStatusMessage("Data exported, but chart data missing.", true);
          }
        } catch (error) {
          exportDisplay.textContent = `Error exporting/charting data: ${error.message}`;
          setStatusMessage(
            `Error exporting/charting data: ${error.message}`,
            true
          );
        }
      });

      // Listener for cost map radio buttons
      costmapRadios.forEach((radio) => {
        radio.addEventListener("change", async (event) => {
          const selectedMode = event.target.value;
          if (selectedMode !== "none") {
            // Always fetch fresh cost data when switching TO a cost map view
            setStatusMessage("Fetching latest cost data for visualization...");
            await fetchGridCosts(); // Fetch fresh data
            if (!gridCostData) {
              setStatusMessage(
                `Failed to load cost data for mode '${selectedMode}'.`,
                true
              );
              return; // Don't render if fetch failed
            }
          }
          // Render (or clear if mode is 'none')
          renderCostGridLayer(selectedMode);
        });
      });

      // --- Initial Load ---
      async function init() {
        setStatusMessage("Initializing map...", false);
        initMap();
        await fetchMetadata(); // Fetch initial state
        // Don't fetch/render costs until simulation is initialized
        if (!status.classList.contains("error-message")) {
          setStatusMessage("Ready. Initialize simulation.");
        }
        updateButtonStates(); // Ensure buttons reflect initial state
      }

      // Start the application
      init();
    </script>
  </body>
</html>
